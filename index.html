<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GPS + Accelerometer Synth</title>
  <style>
    body { font-family: sans-serif; text-align: center; padding: 2em; }
    #status { margin-top: 1em; }
    canvas { display: block; margin: 1em auto; }
  </style>
</head>
<body>
  <h1>GPS + Accelerometer Synth</h1>
  <p>Move away from locked position to change pitch. MIDI out enabled.</p>
  <button onclick="startApp()">Start Synth</button>
  <div id="status"></div>
  <script>
    let audioCtx, osc, gain;
    let lockedPosition = null;
    let accelerationMagnitude = 0;
    let accBuffer = [];
    const ACC_THRESHOLD = 0.2;

    let midiAccess, midiOutput;

    navigator.requestMIDIAccess().then(access => {
      midiAccess = access;
      const outputs = Array.from(midiAccess.outputs.values());
      if (outputs.length > 0) {
        midiOutput = outputs[0];
        console.log("MIDI Output ready:", midiOutput.name);
      }
    });

    function startApp() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        osc = audioCtx.createOscillator();
        gain = audioCtx.createGain();
        osc.connect(gain).connect(audioCtx.destination);
        osc.type = 'sine';
        osc.start();
      }
      document.getElementById('status').textContent = "Locking position...";

      navigator.geolocation.getCurrentPosition(pos => {
        lockedPosition = pos.coords;
        document.getElementById('status').textContent = `Locked at Lat: ${lockedPosition.latitude.toFixed(6)}, Lon: ${lockedPosition.longitude.toFixed(6)}`;
        watchPosition();
        watchMotion();
      }, err => {
        document.getElementById('status').textContent = `Error locking position: ${err.message}`;
      });
    }

    function watchPosition() {
      navigator.geolocation.watchPosition(onPositionUpdate, onPositionError, {
        enableHighAccuracy: false,
        timeout: 5000,
        maximumAge: 10000
      });
    }

    function onPositionUpdate(position) {
      if (!lockedPosition) return;
      const dist = getDistance(position.coords, lockedPosition);

      // Frequency mapping: 200Hz to 2000Hz over 10m+
      const freq = mapRange(dist, 0, 10, 200, 2000);
      const accFactor = Math.max(accelerationMagnitude, 1);
      const modulatedFreq = freq * accFactor;

      if (osc && gain) {
        osc.frequency.setValueAtTime(modulatedFreq, audioCtx.currentTime);
        gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
      }

      if (midiOutput) {
        const midiNote = Math.min(127, Math.floor(mapRange(modulatedFreq, 200, 2000, 40, 100)));
        midiOutput.send([0x90, midiNote, 100]); // Note on
        setTimeout(() => midiOutput.send([0x80, midiNote, 0]), 200); // Note off
      }

      document.getElementById('status').textContent = `Distance: ${dist.toFixed(2)}m, Freq: ${modulatedFreq.toFixed(1)}Hz`;
    }

    function onPositionError(err) {
      console.error("Geolocation error:", err);
    }

    function watchMotion() {
      window.addEventListener('devicemotion', (event) => {
        const ax = event.acceleration.x || 0;
        const ay = event.acceleration.y || 0;
        const az = event.acceleration.z || 0;
        let acc = Math.sqrt(ax*ax + ay*ay + az*az);

        accBuffer.push(acc);
        if (accBuffer.length > 5) accBuffer.shift();
        let avg = accBuffer.reduce((a, b) => a + b, 0) / accBuffer.length;

        accelerationMagnitude = avg > ACC_THRESHOLD ? avg : 1;
      });
    }

    function getDistance(coord1, coord2) {
      const R = 6371e3; // meters
      const toRad = x => x * Math.PI / 180;
      const dLat = toRad(coord2.latitude - coord1.latitude);
      const dLon = toRad(coord2.longitude - coord1.longitude);
      const lat1 = toRad(coord1.latitude);
      const lat2 = toRad(coord2.latitude);

      const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1) * Math.cos(lat2) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

      return R * c / 1000; // in meters
    }

    function mapRange(val, inMin, inMax, outMin, outMax) {
      val = Math.max(inMin, Math.min(inMax, val));
      return outMin + (val - inMin) * (outMax - outMin) / (inMax - inMin);
    }
  </script>
</body>
</html>
